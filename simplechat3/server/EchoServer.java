package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.util.Observable;import java.util.Observer;import java.util.StringTokenizer;import common.*;import com.lloseng.ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer{	//Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;	ChatIF serverUI;	ObservableOriginatorServer obsServer;	//Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) 	{		this.obsServer = new ObservableOriginatorServer(port);		this.obsServer.addObserver(this);		this.serverUI = serverUI;	}	//Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient	(Object msg, ConnectionToClient client)	{					String message = (String) msg;				boolean cancelConnection = false;				// First Connection		if(client.getInfo("id") == null) {						if(message.charAt(0) == '#') {				// Get action				char[] actionChar = new char[message.length() - 1];				message.getChars(1, message.length(), actionChar, 0);				String actionAndId = String.valueOf(actionChar);					StringTokenizer st = new StringTokenizer(actionAndId);				String id = "";				String action = "";								if(st.countTokens() > 1) {					action = st.nextToken();					id = st.nextToken();				}				if ( (!action.equals("login")) || (id.equals("")) ) {					cancelConnection = true;				}				else {					client.setInfo("id", id);				}					}			else {				cancelConnection = true;			}		} 		// Not first time		else {			if(message.charAt(0) == '#') {								// Client wants to do an action				char[] actionChar = new char[message.length() - 1];				message.getChars(1, message.length(), actionChar, 0);				String action = String.valueOf(actionChar);					// Client wants to login again				if (action == "login") {					try {						client.sendToClient("You can't login again you dummy!");					} catch (IOException e) {						serverUI.display("Can't send to Client...");						e.printStackTrace();					}				}								}				// Client wants to send a message			else {				System.out.println(client.getInfo("id") + " > " + msg);				obsServer.sendToAllClients(client.getInfo("id") + " > " + msg);					}			}				if(cancelConnection) {			try {				client.sendToClient("You forgot to login you dummy! Get out!");				client.close();				serverUI.display("Connection with the client closed.");			} catch (IOException e) {				serverUI.display("Can't send to Client...");				e.printStackTrace();			}		}	}	/**	 * This method handles all data coming from the UI            	 *	 * @param message The message from the UI.    	 */	public void handleMessageFromServerUI(String message) {		if(message.charAt(0) == '#') {			// Get the action 			char[] actionChar = new char[message.length() - 1];			message.getChars(1, message.length(), actionChar, 0);			String action = String.valueOf(actionChar);				performAction(action);		}		else {			obsServer.sendToAllClients("Server MSG> " + message);					}	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server starts listening for connections.	 */		private void performAction(String action){		//Testing if there is a parameter		boolean withParameter = false;		String parameter = "";		StringTokenizer st = new StringTokenizer(action);		if(st.countTokens() > 1) {			withParameter = true;			action = st.nextToken();			parameter = st.nextToken();		}		if (!withParameter) {			//if one word			switch(action){			case("quit"):				if(obsServer.isListening()){					serverUI.display("Disconneting the clients :(");					try {						obsServer.close();					} catch (IOException e) {						serverUI.display("Error closing the server.");						e.printStackTrace();					}				}						quit();						break;			case("stop"):  				obsServer.stopListening();			break;			case("close"):				obsServer.stopListening();			try {				obsServer.close();			} catch (IOException e) {				serverUI.display("Error: could not close connection with clients");				e.printStackTrace();			}						break;			case("start"):				if(obsServer.isListening()){					serverUI.display("You're already started you dummy");				}				else{					try {						obsServer.listen();					} catch (IOException e) {						serverUI.display("Error: cannot listen to new connections");						e.printStackTrace();					}									}			break;			case("getport"):				serverUI.display("Port: "+  obsServer.getPort());							break;			default: 				serverUI.display("Action not known !");			}		}		else {			switch(action){			case("setport"):				if(obsServer.getNumberOfClients() > 0) {					serverUI.display("You can't change your port : clients are connected.");				}				else {					if(parameter.matches("^\\d+$")){						obsServer.setPort(Integer.parseInt(parameter));						serverUI.display("Port set to "+parameter);					}					else{						serverUI.display("Int expected you dummy, how do you expect me to do my job if you give me a string? Seriously I just had the worst day ever and you have to do THIS?");					}				}			break;			default: 				serverUI.display("Action not known !");			}		}	}	/**	 * This method terminates the server.	 */	public void quit() {		System.out.println("Bye bye !");		System.exit(0);	}	//Class methods ***************************************************	@Override	public void update(Observable o, Object arg) {				Object message = ((OriginatorMessage)arg).getMessage();		ConnectionToClient client = ((OriginatorMessage)arg).getOriginator();		switch((String)message) {			case(ObservableServer.CLIENT_CONNECTED):				serverUI.display("A wild client appears!");				break;						case(ObservableServer.CLIENT_DISCONNECTED):				serverUI.display("A wild client disappears! \nInet Address : " + 						client.getInetAddress().toString());						System.out.println("THE CLIENT HAS DISAPPEARED OH MY GOD WHERE DID THEY GO??");				break;						case(ObservableServer.SERVER_STARTED):				serverUI.display("Server listening for connections on port " + obsServer.getPort());							break;									case(ObservableServer.SERVER_STOPPED):				serverUI.display("Server has stopped listening for connections.");				break;						case(ObservableServer.SERVER_CLOSED):				serverUI.display("Server closed.");				break;							case(ObservableServer.LISTENING_EXCEPTION):				serverUI.display((String)message);				break;							case(ObservableServer.CLIENT_EXCEPTION):				serverUI.display((String)message);				serverUI.display((String)client.getInfo("id"));				break;							default:				handleMessageFromClient((String)message, client);					}						}}//End of EchoServer class